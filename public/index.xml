<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>My New Hugo Site</title>
    <link>http://example.org/index.xml</link>
    <description>Recent content on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 13 Nov 2015 21:31:40 -0800</lastBuildDate>
    <atom:link href="http://example.org/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Golang Parsing JSON into Interfaces</title>
      <link>http://example.org/post/golang-parse-to-interface/</link>
      <pubDate>Fri, 13 Nov 2015 21:31:40 -0800</pubDate>
      
      <guid>http://example.org/post/golang-parse-to-interface/</guid>
      <description>

&lt;h2 id=&#34;using-interface-types-when-unmarshalling-json&#34;&gt;Using interface types when unmarshalling JSON&lt;/h2&gt;

&lt;p&gt;Interfaces are an incredibly powerful feature in Go, and JSON is one of the
most ubiquitous serialization formats in use today. If you’re reasonably
new to Go you may not have tried to mash the two together yet, but if you
have, you may have seen an error that looks like &lt;code&gt;json: cannot unmarshal string
into Go value of type Foo&lt;/code&gt;. Clearly the Go creators must have given us a way
to leverage interfaces when unmarshalling JSON!&lt;/p&gt;

&lt;p&gt;We’re going to use the following short sample code to illustrate how to achieve this magic:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;encoding/json&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;math&amp;quot;
)

type Shape interface {
	Name() string
	Area() float64
	Circumference() float64
}

type Square struct {
	Size int `json:&amp;quot;size&amp;quot;`
}

func (s Square) Name() string {
	return &amp;quot;square&amp;quot;
}

func (s Square) Area() float64 {
	return float64(s.Size * s.Size)
}

func (s Square) Circumference() float64 {
	return float64(4 * s.Size)
}

type Circle struct {
	Radius int `json:&amp;quot;radius&amp;quot;`
}

func (c Circle) Name() string {
	return &amp;quot;circle&amp;quot;
}

func (c Circle) Area() float64 {
	return math.Pi * float64(c.Radius*c.Radius)
}

func (c Circle) Circumference() float64 {
	return math.Pi * float64(c.Radius*2)
}

type Scene struct {
	Shapes map[string]Shape `json:&amp;quot;shapes&amp;quot;`
}

func main() {
	data := []byte(`{&amp;quot;shapes&amp;quot;:{
		&amp;quot;square&amp;quot;: {
			&amp;quot;size&amp;quot;: 2
		},
		&amp;quot;circle&amp;quot;: {
			&amp;quot;radius&amp;quot;: 1
		}
	}}`)
	s := Scene{}
	err := json.Unmarshal(data, &amp;amp;s)
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Println(s.Shapes)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hopefully it’s reasonably clear why it’s impossible to unmarshal into an
interface. Interfaces have no fields and no concrete underlying data structure
into which to unmarshal the JSON. They are simply a definition of behaviour
(a collection of methods) required to satisfy a particular use case. So how
would we go about using the power and flexibility of interfaces during JSON
unmarshalling?&lt;/p&gt;

&lt;p&gt;If you’ve poked around the &lt;code&gt;encoding/json&lt;/code&gt; package, you may have noticed it has
an interface of its own that looks interesting. It’s the &lt;code&gt;Unmarshaller&lt;/code&gt;. This
interface provides a way for structs to define their own unmarshalling logic.
Still we run into the problem that interfaces are not concrete, so our
interface cannot possibly implement &lt;code&gt;Unmarshaller&lt;/code&gt; itself.&lt;/p&gt;

&lt;p&gt;However, if we hoist the concept up one level, what if we define a type for
our Scene.Shapes map. It might look like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type ShapeMap map[string]Shape

type Scene struct {
	Shapes ShapeMap `json:&amp;quot;shapes&amp;quot;`
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Simple right? Also not quite enough yet. All we’ve done so far is create
another layer of indirection but we’re still, at the end of the day,
attempting to unmarshal JSON into an interface. So what about that
&lt;code&gt;Unmarshaller&lt;/code&gt; interface? The &lt;code&gt;encoding/json&lt;/code&gt; library detects if a struct
implements the interface and will automatically delegate unmarshalling,
so what would our &lt;code&gt;UnmarshalJSON&lt;/code&gt; function for &lt;code&gt;ShapeMap&lt;/code&gt; look like? Let’s
take a look:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type ShapeMap map[string]Shape

func (sm *ShapeMap) UnmarshalJSON(data []byte) error {
	shapes := make(map[string]json.RawMessage)
	err := json.Unmarshal(data, &amp;amp;shapes)
	if err != nil {
		return err
	}
	result := make(ShapeMap)
	for k, v := range shapes {
		switch k {
		case &amp;quot;square&amp;quot;:
			s := Square{}
			err := json.Unmarshal(v, &amp;amp;s)
			if err != nil {
				return err
			}
			result[k] = s
		case &amp;quot;circle&amp;quot;:
			c := Circle{}
			err := json.Unmarshal(v, &amp;amp;c)
			if err != nil {
				return err
			}
			result[k] = c
		default:
			return errors.New(&amp;quot;Unrecognized shape&amp;quot;)
		}
	}
	*sm = result
	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Within our &lt;code&gt;UnmarshalJSON&lt;/code&gt; we partially unmarshal the map making use of
&lt;code&gt;json.RawMessage&lt;/code&gt; to leave the data associated with a shape in serialized form
until we know what type of shape it is by inspection of the map keys. We loop
over this partially unmarshalled map, and unmarshal each shape into the
appropriate struct based on the value of the key. Finally, the line
&lt;code&gt;*sm = result&lt;/code&gt; is something we don’t see a lot of Go, there’s rarely call
for it. Here we are dereferencing the pointer to the receiver struct and
assigning the value of the result map to it. This gives the receiver the value
of result in its entirety. If the receiver already contained some state, it
would get replaced.&lt;/p&gt;

&lt;p&gt;Providing a full final example, this now allows us to unmarshal JSON into an
interface type via a little indirection and use of a couple of handy
&lt;code&gt;encoding/json&lt;/code&gt; features, the &lt;code&gt;Unmarshaller&lt;/code&gt; interface, and &lt;code&gt;RawMessage&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;encoding/json&amp;quot;
	&amp;quot;errors&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;math&amp;quot;
)

type Shape interface {
	Name() string
	Area() float64
	Circumference() float64
}

type Square struct {
	Size int `json:&amp;quot;size&amp;quot;`
}

func (s Square) Name() string {
	return &amp;quot;square&amp;quot;
}

func (s Square) Area() float64 {
	return float64(s.Size * s.Size)
}

func (s Square) Circumference() float64 {
	return float64(4 * s.Size)
}

type Circle struct {
	Radius int `json:&amp;quot;radius&amp;quot;`
}

func (c Circle) Name() string {
	return &amp;quot;circle&amp;quot;
}

func (c Circle) Area() float64 {
	return math.Pi * float64(c.Radius*c.Radius)
}

func (c Circle) Circumference() float64 {
	return math.Pi * float64(c.Radius*2)
}

type ShapeMap map[string]Shape

func (sm *ShapeMap) UnmarshalJSON(data []byte) error {
	shapes := make(map[string]json.RawMessage)
	err := json.Unmarshal(data, &amp;amp;shapes)
	if err != nil {
		return err
	}
	result := make(ShapeMap)
	for k, v := range shapes {
		switch k {
		case &amp;quot;square&amp;quot;:
			s := Square{}
			err := json.Unmarshal(v, &amp;amp;s)
			if err != nil {
				return err
			}
			result[k] = s
		case &amp;quot;circle&amp;quot;:
			c := Circle{}
			err := json.Unmarshal(v, &amp;amp;c)
			if err != nil {
				return err
			}
			result[k] = c
		default:
			return errors.New(&amp;quot;Unrecognized shape&amp;quot;)
		}
	}
	*sm = result
	return nil
}

type Scene struct {
	Shapes ShapeMap `json:&amp;quot;shapes&amp;quot;`
}

func main() {
	data := []byte(`{&amp;quot;shapes&amp;quot;:{
		&amp;quot;square&amp;quot;: {
			&amp;quot;size&amp;quot;: 2
		},
		&amp;quot;circle&amp;quot;: {
			&amp;quot;radius&amp;quot;: 1
		}
	}}`)
	s := Scene{}
	err := json.Unmarshal(data, &amp;amp;s)
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Println(s.Shapes)
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>